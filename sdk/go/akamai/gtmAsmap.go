// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package akamai

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Use the `GtmAsmap` resource to create, configure, and import a GTM Autonomous System (AS) map. AS mapping lets you configure a GTM property that returns a CNAME based on the AS number associated with the requester's IP address.
//
// You can reuse maps for multiple properties or create new ones. AS maps split the Internet into multiple AS block zones. Properties that use AS maps can specify handout integers for each zone. AS mapping lets you configure a property that directs users to a specific environment or to the origin.
//
// > **Note** Import requires an ID with this format: `existingDomainName`:`existingMapName`.
//
// ## Example Usage
//
// Basic usage:
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-akamai/sdk/v2/go/akamai"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := akamai.NewGtmAsmap(ctx, "demoAsmap", &akamai.GtmAsmapArgs{
// 			DefaultDatacenter: &GtmAsmapDefaultDatacenterArgs{
// 				DatacenterId: pulumi.Int(5400),
// 				Nickname:     pulumi.String("All Other AS numbers"),
// 			},
// 			Domain: pulumi.String("demo_domain.akadns.net"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
// ## Argument reference
//
// This resource supports these arguments:
//
// * `domain` - (Required) The GTM Domain name for the AS map.
// * `name` - (Required) A descriptive label for the AS map. Properties set up for  AS mapping can use this as reference.
// * `defaultDatacenter` - (Required) A placeholder for all other AS zones not found in these AS zones. Requires these additional arguments:
//   * `datacenterId` - (Required) A unique identifier for an existing data center in the domain.
//   * `nickname` - (Required) A descriptive label for all other AS zones, up to 128 characters.
// * `waitOnComplete` - (Optional) A boolean that, if `true`, waits for transaction to complete.
// * `assignment` - (Optional) Contains information about the AS zone groupings of AS IDs. You can have multiple entries with this argument. If used, requires these arguments:
//   * `datacenterId` - A unique identifier for an existing data center in the domain.
//   * `nickname` - A descriptive label for the group.
//   * `asNumbers` - Specifies an array of AS numbers.
//
// ## Schema reference
//
// You can download the GTM AS Map backing schema from the [Global Traffic Management API](https://developer.akamai.com/api/web_performance/global_traffic_management/v1.html#asmap) page.
type GtmAsmap struct {
	pulumi.CustomResourceState

	Assignments       GtmAsmapAssignmentArrayOutput   `pulumi:"assignments"`
	DefaultDatacenter GtmAsmapDefaultDatacenterOutput `pulumi:"defaultDatacenter"`
	Domain            pulumi.StringOutput             `pulumi:"domain"`
	Name              pulumi.StringOutput             `pulumi:"name"`
	WaitOnComplete    pulumi.BoolPtrOutput            `pulumi:"waitOnComplete"`
}

// NewGtmAsmap registers a new resource with the given unique name, arguments, and options.
func NewGtmAsmap(ctx *pulumi.Context,
	name string, args *GtmAsmapArgs, opts ...pulumi.ResourceOption) (*GtmAsmap, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DefaultDatacenter == nil {
		return nil, errors.New("invalid value for required argument 'DefaultDatacenter'")
	}
	if args.Domain == nil {
		return nil, errors.New("invalid value for required argument 'Domain'")
	}
	aliases := pulumi.Aliases([]pulumi.Alias{
		{
			Type: pulumi.String("akamai:trafficmanagement/gtmASmap:GtmASmap"),
		},
	})
	opts = append(opts, aliases)
	var resource GtmAsmap
	err := ctx.RegisterResource("akamai:index/gtmAsmap:GtmAsmap", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetGtmAsmap gets an existing GtmAsmap resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetGtmAsmap(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *GtmAsmapState, opts ...pulumi.ResourceOption) (*GtmAsmap, error) {
	var resource GtmAsmap
	err := ctx.ReadResource("akamai:index/gtmAsmap:GtmAsmap", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering GtmAsmap resources.
type gtmAsmapState struct {
	Assignments       []GtmAsmapAssignment       `pulumi:"assignments"`
	DefaultDatacenter *GtmAsmapDefaultDatacenter `pulumi:"defaultDatacenter"`
	Domain            *string                    `pulumi:"domain"`
	Name              *string                    `pulumi:"name"`
	WaitOnComplete    *bool                      `pulumi:"waitOnComplete"`
}

type GtmAsmapState struct {
	Assignments       GtmAsmapAssignmentArrayInput
	DefaultDatacenter GtmAsmapDefaultDatacenterPtrInput
	Domain            pulumi.StringPtrInput
	Name              pulumi.StringPtrInput
	WaitOnComplete    pulumi.BoolPtrInput
}

func (GtmAsmapState) ElementType() reflect.Type {
	return reflect.TypeOf((*gtmAsmapState)(nil)).Elem()
}

type gtmAsmapArgs struct {
	Assignments       []GtmAsmapAssignment      `pulumi:"assignments"`
	DefaultDatacenter GtmAsmapDefaultDatacenter `pulumi:"defaultDatacenter"`
	Domain            string                    `pulumi:"domain"`
	Name              *string                   `pulumi:"name"`
	WaitOnComplete    *bool                     `pulumi:"waitOnComplete"`
}

// The set of arguments for constructing a GtmAsmap resource.
type GtmAsmapArgs struct {
	Assignments       GtmAsmapAssignmentArrayInput
	DefaultDatacenter GtmAsmapDefaultDatacenterInput
	Domain            pulumi.StringInput
	Name              pulumi.StringPtrInput
	WaitOnComplete    pulumi.BoolPtrInput
}

func (GtmAsmapArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*gtmAsmapArgs)(nil)).Elem()
}

type GtmAsmapInput interface {
	pulumi.Input

	ToGtmAsmapOutput() GtmAsmapOutput
	ToGtmAsmapOutputWithContext(ctx context.Context) GtmAsmapOutput
}

func (*GtmAsmap) ElementType() reflect.Type {
	return reflect.TypeOf((*GtmAsmap)(nil))
}

func (i *GtmAsmap) ToGtmAsmapOutput() GtmAsmapOutput {
	return i.ToGtmAsmapOutputWithContext(context.Background())
}

func (i *GtmAsmap) ToGtmAsmapOutputWithContext(ctx context.Context) GtmAsmapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GtmAsmapOutput)
}

func (i *GtmAsmap) ToGtmAsmapPtrOutput() GtmAsmapPtrOutput {
	return i.ToGtmAsmapPtrOutputWithContext(context.Background())
}

func (i *GtmAsmap) ToGtmAsmapPtrOutputWithContext(ctx context.Context) GtmAsmapPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GtmAsmapPtrOutput)
}

type GtmAsmapPtrInput interface {
	pulumi.Input

	ToGtmAsmapPtrOutput() GtmAsmapPtrOutput
	ToGtmAsmapPtrOutputWithContext(ctx context.Context) GtmAsmapPtrOutput
}

type gtmAsmapPtrType GtmAsmapArgs

func (*gtmAsmapPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GtmAsmap)(nil))
}

func (i *gtmAsmapPtrType) ToGtmAsmapPtrOutput() GtmAsmapPtrOutput {
	return i.ToGtmAsmapPtrOutputWithContext(context.Background())
}

func (i *gtmAsmapPtrType) ToGtmAsmapPtrOutputWithContext(ctx context.Context) GtmAsmapPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GtmAsmapPtrOutput)
}

// GtmAsmapArrayInput is an input type that accepts GtmAsmapArray and GtmAsmapArrayOutput values.
// You can construct a concrete instance of `GtmAsmapArrayInput` via:
//
//          GtmAsmapArray{ GtmAsmapArgs{...} }
type GtmAsmapArrayInput interface {
	pulumi.Input

	ToGtmAsmapArrayOutput() GtmAsmapArrayOutput
	ToGtmAsmapArrayOutputWithContext(context.Context) GtmAsmapArrayOutput
}

type GtmAsmapArray []GtmAsmapInput

func (GtmAsmapArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*GtmAsmap)(nil)).Elem()
}

func (i GtmAsmapArray) ToGtmAsmapArrayOutput() GtmAsmapArrayOutput {
	return i.ToGtmAsmapArrayOutputWithContext(context.Background())
}

func (i GtmAsmapArray) ToGtmAsmapArrayOutputWithContext(ctx context.Context) GtmAsmapArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GtmAsmapArrayOutput)
}

// GtmAsmapMapInput is an input type that accepts GtmAsmapMap and GtmAsmapMapOutput values.
// You can construct a concrete instance of `GtmAsmapMapInput` via:
//
//          GtmAsmapMap{ "key": GtmAsmapArgs{...} }
type GtmAsmapMapInput interface {
	pulumi.Input

	ToGtmAsmapMapOutput() GtmAsmapMapOutput
	ToGtmAsmapMapOutputWithContext(context.Context) GtmAsmapMapOutput
}

type GtmAsmapMap map[string]GtmAsmapInput

func (GtmAsmapMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*GtmAsmap)(nil)).Elem()
}

func (i GtmAsmapMap) ToGtmAsmapMapOutput() GtmAsmapMapOutput {
	return i.ToGtmAsmapMapOutputWithContext(context.Background())
}

func (i GtmAsmapMap) ToGtmAsmapMapOutputWithContext(ctx context.Context) GtmAsmapMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GtmAsmapMapOutput)
}

type GtmAsmapOutput struct{ *pulumi.OutputState }

func (GtmAsmapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GtmAsmap)(nil))
}

func (o GtmAsmapOutput) ToGtmAsmapOutput() GtmAsmapOutput {
	return o
}

func (o GtmAsmapOutput) ToGtmAsmapOutputWithContext(ctx context.Context) GtmAsmapOutput {
	return o
}

func (o GtmAsmapOutput) ToGtmAsmapPtrOutput() GtmAsmapPtrOutput {
	return o.ToGtmAsmapPtrOutputWithContext(context.Background())
}

func (o GtmAsmapOutput) ToGtmAsmapPtrOutputWithContext(ctx context.Context) GtmAsmapPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GtmAsmap) *GtmAsmap {
		return &v
	}).(GtmAsmapPtrOutput)
}

type GtmAsmapPtrOutput struct{ *pulumi.OutputState }

func (GtmAsmapPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GtmAsmap)(nil))
}

func (o GtmAsmapPtrOutput) ToGtmAsmapPtrOutput() GtmAsmapPtrOutput {
	return o
}

func (o GtmAsmapPtrOutput) ToGtmAsmapPtrOutputWithContext(ctx context.Context) GtmAsmapPtrOutput {
	return o
}

func (o GtmAsmapPtrOutput) Elem() GtmAsmapOutput {
	return o.ApplyT(func(v *GtmAsmap) GtmAsmap {
		if v != nil {
			return *v
		}
		var ret GtmAsmap
		return ret
	}).(GtmAsmapOutput)
}

type GtmAsmapArrayOutput struct{ *pulumi.OutputState }

func (GtmAsmapArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GtmAsmap)(nil))
}

func (o GtmAsmapArrayOutput) ToGtmAsmapArrayOutput() GtmAsmapArrayOutput {
	return o
}

func (o GtmAsmapArrayOutput) ToGtmAsmapArrayOutputWithContext(ctx context.Context) GtmAsmapArrayOutput {
	return o
}

func (o GtmAsmapArrayOutput) Index(i pulumi.IntInput) GtmAsmapOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GtmAsmap {
		return vs[0].([]GtmAsmap)[vs[1].(int)]
	}).(GtmAsmapOutput)
}

type GtmAsmapMapOutput struct{ *pulumi.OutputState }

func (GtmAsmapMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]GtmAsmap)(nil))
}

func (o GtmAsmapMapOutput) ToGtmAsmapMapOutput() GtmAsmapMapOutput {
	return o
}

func (o GtmAsmapMapOutput) ToGtmAsmapMapOutputWithContext(ctx context.Context) GtmAsmapMapOutput {
	return o
}

func (o GtmAsmapMapOutput) MapIndex(k pulumi.StringInput) GtmAsmapOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) GtmAsmap {
		return vs[0].(map[string]GtmAsmap)[vs[1].(string)]
	}).(GtmAsmapOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*GtmAsmapInput)(nil)).Elem(), &GtmAsmap{})
	pulumi.RegisterInputType(reflect.TypeOf((*GtmAsmapPtrInput)(nil)).Elem(), &GtmAsmap{})
	pulumi.RegisterInputType(reflect.TypeOf((*GtmAsmapArrayInput)(nil)).Elem(), GtmAsmapArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GtmAsmapMapInput)(nil)).Elem(), GtmAsmapMap{})
	pulumi.RegisterOutputType(GtmAsmapOutput{})
	pulumi.RegisterOutputType(GtmAsmapPtrOutput{})
	pulumi.RegisterOutputType(GtmAsmapArrayOutput{})
	pulumi.RegisterOutputType(GtmAsmapMapOutput{})
}
